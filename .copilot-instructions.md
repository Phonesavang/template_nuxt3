# Copilot Instructions for Nuxt 3 Template Project

## Project Overview

This is a Nuxt 3 template project with Vuetify UI framework, Pinia state management, and i18n internationalization support for Lao and English languages.

## Tech Stack

- **Framework**: Nuxt 3
- **UI Library**: Vuetify 3
- **State Management**: Pinia
- **Internationalization**: @nuxtjs/i18n
- **Language**: TypeScript
- **HTTP Client**: Axios
- **Styling**: SCSS, CSS
- **Alert/Notification**: SweetAlert2

## Project Structure

```
template_nuxt3/
├── assets/
│   └── css/                 # Global styles (main.css, style.scss)
├── components/
│   ├── AppHeader.vue        # Main header component
│   └── global/              # Reusable components
│       ├── AutocompleteInput.vue
│       ├── Breadcrumbs.vue
│       ├── ComboboxInput.vue
│       ├── InputDatePicker.vue
│       ├── InputTextField.vue
│       ├── LanguageSwitcher.vue
│       ├── Pagination.vue
│       └── SelectInput.vue
├── composables/
│   └── global.ts            # Global composables and utilities
├── layouts/
│   ├── default.vue          # Default layout
│   └── dataTab.ts           # Tab data configuration
├── locales/                 # i18n translation files
│   ├── en.json              # English translations
│   └── lo.json              # Lao translations
├── middleware/
│   ├── auth.global.ts       # Authentication middleware
│   └── i18n.global.ts       # i18n middleware
├── pages/                   # File-based routing
├── plugins/
│   ├── axios.ts             # Axios configuration
│   └── vuetify.ts           # Vuetify configuration
├── stores/
│   └── global.ts            # Pinia global store
└── types/
    └── nuxt.d.ts            # Type definitions
```

## Coding Guidelines

### 1. Vue 3 Composition API

- Always use `<script setup lang="ts">` syntax
- Use `ref()` and `reactive()` for reactive data
- Use `computed()` for computed properties
- Use `watch()` and `watchEffect()` for watchers

### 2. TypeScript

- All files should use TypeScript
- Define interfaces for complex objects
- Use proper typing for props, emits, and return values
- Avoid `any` type, use specific types or generics

### 3. Internationalization (i18n)

- **Default Language**: Lao (lo)
- **Secondary Language**: English (en)
- Always use `t()` function for translatable text: `{{ t('key') }}`
- Add new translations to both `locales/lo.json` and `locales/en.json`
- Use structured keys: `menu.home`, `common.save`, `form.required`

### 4. Component Naming

- Use PascalCase for component names
- Global components should be in `components/global/`
- Prefix global components appropriately (Input*, Select*, etc.)

### 5. Styling

- Use Vuetify classes first: `d-flex`, `ma-4`, `pa-2`, etc.
- Custom styles in `<style scoped>` when needed
- Global styles in `assets/css/`
- Use SCSS for advanced styling

### 6. State Management (Pinia)

- Use Pinia stores for global state
- Store files in `stores/` directory
- Use `storeToRefs()` for reactive store properties
- Example usage:

```typescript
const { count } = storeToRefs(useStoreGlobal());
const { increment } = useStoreGlobal();
```

### 7. API Calls

- Use Axios plugin configured in `plugins/axios.ts`
- Create composables for API operations
- Handle loading states and errors properly

### 8. Form Handling

- Use Vuetify form components
- Implement proper validation
- Use custom input components from `components/global/`

### 9. Notifications and Dialogs

- Use `dialogConfirm()` for confirmation dialogs
- Use `notification()` for success/error messages
- Both are available from `composables/global.ts`

## Common Patterns

### Page Structure

```vue
<script setup lang="ts">
// i18n
const { t } = useI18n();

// Page meta (if needed)
definePageMeta({
  layout: "default", // or false for no layout
});

// Reactive data
const loading = ref(false);
const data = ref([]);

// Methods
const fetchData = async () => {
  loading.value = true;
  try {
    // API call
  } catch (error) {
    await notification("error", t("common.error"), 3000);
  } finally {
    loading.value = false;
  }
};
</script>

<template>
  <section>
    <v-container>
      <h1>{{ t("page.title") }}</h1>
      <!-- Content -->
    </v-container>
  </section>
</template>
```

### Component Structure

```vue
<script setup lang="ts">
// Props
interface Props {
  title: string;
  items: Array<any>;
  loading?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  loading: false,
});

// Emits
const emit = defineEmits<{
  select: [item: any];
  close: [];
}>();

// i18n
const { t } = useI18n();
</script>

<template>
  <v-card>
    <v-card-title>{{ props.title }}</v-card-title>
    <v-card-text>
      <!-- Content -->
    </v-card-text>
  </v-card>
</template>
```

## Language Switching

- Use `<LanguageSwitcher />` component
- Language preference is saved in localStorage
- Use `useLanguage()` composable for programmatic switching

## Best Practices

### Performance

- Use `lazy` loading for heavy components
- Implement proper loading states
- Use `v-show` vs `v-if` appropriately

### SEO & Accessibility

- Use semantic HTML
- Add proper ARIA labels
- Use Nuxt's SEO features

### Error Handling

- Always wrap API calls in try-catch
- Show user-friendly error messages
- Log errors for debugging

### Security

- Validate all user inputs
- Use HTTPS in production
- Implement proper authentication checks

## File Naming Conventions

- **Components**: PascalCase (e.g., `InputTextField.vue`)
- **Pages**: kebab-case (e.g., `user-profile.vue`)
- **Composables**: camelCase (e.g., `useUserData.ts`)
- **Stores**: camelCase (e.g., `userStore.ts`)
- **Types**: PascalCase interfaces (e.g., `UserInterface`)

## Dependencies to Consider

- Form validation: Consider adding VeeValidate
- Date handling: Consider adding day.js or date-fns
- Charts: Consider adding Chart.js or ApexCharts
- Icons: Vuetify uses Material Design Icons (mdi-\*)

## Testing Guidelines

- Write unit tests for utilities and composables
- Test components with user interactions
- Test i18n functionality with both languages

Remember to:

- Keep components small and focused
- Use composables for reusable logic
- Follow the established project patterns
- Test both Lao and English languages
- Maintain consistent code style
- Document complex logic with comments
